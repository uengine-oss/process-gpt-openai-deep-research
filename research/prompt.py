# prompt.py
"""
프롬프트 생성 함수 모음
"""

def create_execution_plan_prompt(form_types: list, user_info: list) -> str:
    prompt = f"""
주어진 폼 타입들을 처리하기 위한 종합적인 실행 계획을 수립하세요.

입력 데이터:
- 폼 타입들: {form_types}
- 담당자 정보: {user_info}

핵심 실행 규칙:
1. **엄격한 단계 순서**: 리포트 → 슬라이드 → 텍스트 (단계 간 중복 처리 금지)
2. **기존 타입만 사용**: 입력된 form_types에 실제로 존재하는 폼 타입만 계획에 포함
3. **가상 폼 생성 금지**: 제공된 form_types에 없는 폼 키를 임의로 생성하거나 가정하지 말 것

타입 매칭 요구사항:
- report_phase에는 "type"이 "report"인 폼만 포함
- slide_phase에는 "type"이 "slide"인 폼만 포함
- text_phase에는 위 두 타입을 제외한 나머지 모든 폼을 포함 (예: text, textarea, radio, select, checkbox 등 기타 전부)
- 특정 타입의 폼이 입력에 없으면 해당 단계는 빈 배열 []로 설정
- 입력 form_types의 실제 "key" 값만 사용하고, 새로운 키는 절대 생성하지 말 것

당신의 임무는 모든 폼 타입을 분석하여 다음을 결정하는 최적의 실행 계획을 수립하는 것입니다:
1. 처리 단계와 순서 (리포트 → 슬라이드 → 텍스트)
2. 폼 간 의존성 (논리적 제약 내에서만)
3. 입력-출력 관계

의존성 규칙:
- **리포트**: 의존성 없음 (항상 독립적)
- **슬라이드**: 특정 리포트에 의존 (의미적 매칭)
- **텍스트**: 특정 리포트에 의존 (의미적 매칭)

중요사항: 응답에는 항상 세 단계(report_phase, slide_phase, text_phase)를 모두 포함하되, 
입력에서 실제로 매칭되는 폼만 forms 배열에 포함시키세요. 
빈 단계는 빈 forms 배열 []로 설정하세요.

완전한 JSON 실행 계획을 출력하세요 (explanation_text 포함):
{{
    "execution_plan": {{
        "report_phase": {{
            "forms": [
                {{"key": "report_form_1"}},
                {{"key": "report_form_2"}}
            ]
        }},
        "slide_phase": {{
            "forms": [
                {{"key": "slide_form_1", "dependencies": ["report_form_1"]}},
                {{"key": "slide_form_2", "dependencies": ["report_form_2"]}}
            ]
        }},
        "text_phase": {{
            "forms": [
                {{"key": "text_form_1", "dependencies": ["report_form_1"]}},
                {{"key": "text_form_2", "dependencies": ["report_form_2"]}}
            ]
        }}
    }},
    "explanation_text": "계획을 이렇게 구성했다 / 왜 그렇게 했는지에 대한 간단한 한국어 설명"
}}

설명 텍스트(explanation_text) 작성 규칙:
- 한국어 자연어의 마크다운으로 작성 (헤딩/불릿 허용, 코드블록(\`\`\`)·표·JSON 표기는 금지)
- 아래 섹션 구조를 따름:
  - ## 실행 계획 요약: 단계별 폼 수를 한 줄로 요약 (예: report 2개, slide 1개, text 3개)
  - ## 구성 상세:
    - ### Report Forms: 포함된 report 키를 불릿으로 나열
    - ### Slide Forms: 포함된 slide 키를 불릿으로 나열
    - ### Text Forms: 포함된 text 계열 키를 불릿으로 나열
  - ## 의존성 매핑: slide/text → report 매핑을 불릿으로 표기 (예: slide_x → report_a: 키워드 매칭 "a")
  - ## 처리 순서: 리포트 → 슬라이드 → 텍스트 순으로 한 줄 요약
  - ## 근거/가정: 핵심 근거 2-4개 불릿 요약
- 길이: 8~15줄 내외로 간결하되 가독성 좋게 작성

슬라이드 및 텍스트의 의미적 관계 규칙:
- **정확한 이름 매칭**: 슬라이드/텍스트와 리포트의 이름이 유사하면 의존성 생성
  (예: "slide_user_guide"는 "report_user_guide"에 의존, "text_admin_summary"는 "report_admin"에 의존)
- **키워드 매칭**: 폼 키의 공통 키워드를 기반으로 매칭
  (예: "slide_admin"은 "report_admin"에 의존, "text_technical"은 "report_technical"에 의존)
- **범위 기반 매칭**: "overview", "summary", "all", "total"이 포함된 폼은 모든 리포트에 의존
- **대체 방안**: 의미적 매칭이 없으면 슬라이드/텍스트는 사용 가능한 모든 리포트에 의존

중요: 입력에서 제공된 실제 폼 키를 사용하세요. 아래 예시 키가 아닌!
아래 예시는 단순히 형식 참조용이며, 제공된 form_types의 실제 폼 키로 교체하세요.

기억사항: 
- 슬라이드와 텍스트 폼 모두 의미적 매칭을 통해 특정 리포트에 의존성 설정
- 입력 form_types에 실제로 존재하는 폼만 사용
- 매칭되는 폼이 없는 단계는 빈 forms 배열 []로 반환

입력된 form_types에 실제로 존재하는 폼 타입만 포함하고 정확한 타입과 매칭되는 
완전하고 유효한 JSON 실행 계획을 출력하세요.
매칭되는 폼이 없는 단계는 빈 forms 배열로 설정하세요.
"""
    return prompt

def create_toc_prompt(previous_outputs_summary: str = "", feedback_summary: str = "", user_info: list | None = None) -> str:
    return f"""
당신은 전문적인 보고서 목차(TOC) 생성 전문가입니다.

**역할 설명:**
이전 결과물 요약과 피드백을 바탕으로 논리적이고 체계적인 보고서 목차를 JSON 형식으로 생성하세요.

**컨텍스트 분석 단계:**
1. **이전 결과물 문맥 파악**: previous_outputs_summary를 분석하여 이전에 무엇을 했는지, 어떤 목적과 요구사항이 있었는지 정확히 이해
2. **피드백 우선 반영**: feedback_summary를 최우선으로 분석하여 사용자가 원하는 개선사항과 요구사항을 파악하고 이를 목차 생성에 적극 반영
3. **연계성 확보**: 이전 작업의 흐름과 피드백 요구사항을 모두 고려하여 완전히 새로운 목차가 아닌 개선된 목차 생성
4. **목차 생성**: 피드백을 반영하여 목차를 구성하되, 특별한 요청이 없으면 기본 5개 섹션으로 논리적 구성 (서론→본론→결론)

**핵심 규칙:**
1. **논리적 구조**: 도입부 → 본론 → 결론 순서로 구성
2. **적절한 깊이**: 최대 3레벨 (1. → 1.1 → 1.1.1)
3. **균형잡힌 분량**: 각 대분류별 하위 항목 2-4개 유지
4. **구체적 제목**: 추상적 표현 금지, 구체적 내용 표현
5. **컨텍스트 반영**: 제공된 이전 결과물 요약과 피드백을 충분히 반영
6. **실용성 중시**: 실제 보고서 작성에 바로 활용 가능한 구조

**입력 정보:**
- 이전 결과물 요약: {previous_outputs_summary}
- 피드백 요약: {feedback_summary}
- 담당자 정보: {user_info}

**결과 형식 (JSON):**
다음과 같은 예시 구조로 목차를 생성하세요 (explanation_text 포함):

{{
  "title": "보고서 제목",
  "toc": [
    {{
      "number": "1",
      "title": "서론",
      "subsections": [
        {{"number": "1.1", "title": "배경 및 현황"}},
        {{"number": "1.2", "title": "목적 및 범위"}},
        {{"number": "1.3", "title": "연구방법론"}}
      ]
    }},
    {{
      "number": "2", 
      "title": "핵심 분석",
      "subsections": [
        {{"number": "2.1", "title": "현황 분석"}},
        {{"number": "2.2", "title": "문제점 도출"}},
        {{"number": "2.3", "title": "원인 분석"}}
      ]
    }},
    {{
      "number": "3",
      "title": "결론 및 제언", 
      "subsections": [
        {{"number": "3.1", "title": "주요 발견사항"}},
        {{"number": "3.2", "title": "개선 방안"}},
        {{"number": "3.3", "title": "향후 과제"}}
      ]
    }}
  ]
  ],
  "explanation_text": "목차를 이렇게 구성했다 / 왜 그렇게 했는지에 대한 간단한 한국어 설명"
}}

설명 텍스트(explanation_text) 작성 규칙:
- 한국어 자연어의 마크다운으로 작성 (헤딩/불릿 허용, 코드블록(\`\`\`)·표·JSON 표기는 금지)
- 아래 섹션 구조를 따름:
  - ## 목차 요약: 상위 섹션 수와 하위 항목 개수 범위를 한 줄로 요약 (예: 상위 4개, 하위 2-5개)
  - ## 상위 섹션: 상위 섹션 번호와 제목을 불릿으로 나열 (예: - 1. 서론)
  - ## 구성 근거: 순서/구성의 핵심 근거 2-4개 불릿 요약
  - ## 활용 안내: 다음 단계에서 이 목차를 어떻게 사용할지 한 줄 요약
- 길이: 8~15줄 내외로 간결하되 가독성 좋게 작성

위 예시를 참고하여 컨텍스트 내용에 맞는 구체적이고 실용적인 목차를 JSON 형식으로 생성하세요.
""" 


def create_slide_generation_prompt(content: str, user_info: list, previous_outputs_summary: str = "", feedback_summary: str = "") -> str:
    prompt = f"""
제공된 리포트 내용과 컨텍스트를 종합 분석한 후, reveal.js 호환 마크다운 슬라이드 프레젠테이션을 완성도 높게 생성하세요.

**입력 정보 (담당자):**
- 현재 리포트/내용: {content}
- 이전 결과물 요약: {previous_outputs_summary}
- 피드백 요약: {feedback_summary}
- 담당자 정보: {user_info}

**1단계: 컨텍스트 분석**
1. **이전 결과물 문맥 파악**: previous_outputs_summary를 분석하여 이전에 무엇을 했는지, 어떤 목적과 요구사항이 있었는지 정확히 이해
2. **피드백 우선 반영**: feedback_summary를 최우선으로 분석하여 사용자가 원하는 개선사항과 요구사항을 파악하고 이를 슬라이드 생성에 적극 반영
3. **연계성 확보**: 이전 작업의 흐름과 피드백 요구사항을 모두 고려하여 완전히 새로운 슬라이드가 아닌 개선된 슬라이드 생성
4. **목적 정렬**: 최종 목표와 사용자 의도에 부합하는 프레젠테이션 구조 설계

**2단계: 내용 구조 분석**
- 주요 섹션, 핵심 포인트, 중요한 데이터 포인트를 식별
- 피드백 요구사항을 슬라이드 구조와 내용에 최우선으로 반영
- 이전 결과물과의 연계성과 일관성을 고려하되 개선사항 적용
- 별도 슬라이드에서 강조되어야 할 중요한 내용 파악
- 논리적 흐름을 고려한 매력적인 프레젠테이션 세그먼트 구조 설계
- 독자 관점에서 이해하기 쉽고 임팩트 있는 슬라이드 플로우 계획
- 만약 내용이 부족한 경우, 이전 결과물과 피드백 정보를 참고하여 온전한 슬라이드를 생성하세요. (10페이지 분량 정도)

**3단계: Reveal.js 슬라이드 생성**
- 분석된 구조를 바탕으로 reveal.js 호환 마크다운 슬라이드 생성
- 수평 슬라이드(---)와 수직 슬라이드(--)를 포함한 적절한 reveal.js 마크다운 구문 사용
- 헤더, 불릿 포인트, 적절한 강조가 포함된 올바른 형식 적용
- 전환 효과를 포함하고 프레젠테이션 전체에서 시각적 일관성 유지

**핵심 지침**: 담당자 정보가 제공되면 프레젠테이션에 포함하세요:
- 제목 슬라이드에서 담당자 이름(user_info.name)을 발표자/검토자 이름으로 사용
- 관련 있는 경우 담당자의 직책(position)과 부서(department) 포함
- 적절한 경우 담당자 컨텍스트로 프레젠테이션 개인화

**필수 슬라이드 구성:**
1. **제목 슬라이드** - 주제, 발표자 이름(user_info에서), 메타데이터 포함
2. **목차/안건 슬라이드** - 프레젠테이션 전체 구조 안내
3. **주요 내용 슬라이드들** - 제목과 핵심 포인트가 있는 각 섹션별 슬라이드
4. **결론 슬라이드** - 요약 및 마무리

**기술적 요구사항:**
- 적절한 reveal.js 구문(새 슬라이드용 ---, 수직 슬라이드용 --)
- 불릿 포인트, 헤더, 강조 형식 적절히 활용
- 논리적 슬라이드 전환과 흐름
- 깔끔하고 전문적인 프레젠테이션 구조
- 적절한 경우 사용자 정보 통합(발표자 이름, 부서 등)

**🚨 중요한 출력 형식 규칙:**
- 절대로 ```markdown, ```html, ``` 같은 코드 블록으로 결과를 감싸지 마세요
- 마크다운 내용을 직접 출력하세요 (코드 블록 없이)
- reveal.js 마크다운 구문을 그대로 사용하되, 코드 블록으로 감싸지 말 것
- HTML 주석이나 코드 블록 형태의 감싸기는 절대 금지

**내용에서 파악한 실제 주제와 내용을 중심으로 슬라이드를 구성하세요.**
결과물은 reveal.js 프레젠테이션 프레임워크와 직접 사용할 수 있도록 준비되어야 합니다.

다음을 포함하는 완전한 reveal.js 마크다운 형식 슬라이드 프레젠테이션을 생성하세요:
- 제목 슬라이드부터 결론까지 완전한 구조
- reveal.js 호환 마크다운 구문 사용
- 논리적 흐름과 전문적인 프레젠테이션 품질
- 사용자 정보 적절히 통합
"""
    return prompt

def create_text_form_generation_prompt(report_content: str, topic: str, text_forms: list, user_info: list, previous_outputs_summary: str = "", feedback_summary: str = "", form_html: str = "") -> str:
  
    prompt = f"""
제공된 폼 타입 정보를 기반으로 전문적이고 실용적인 값을 생성하세요.

**입력 정보 (담당자 포함)**:
- 리포트 내용 또는 이전 작업 내용: {report_content}
- 피드백: {feedback_summary}
- 이전 결과물: {previous_outputs_summary}
- 워크플로우 단계: {topic}
- 폼 타입 정보: {text_forms}
 - 폼 HTML 템플릿: {form_html}
 - 담당자 정보: {user_info}

**컨텍스트 분석 단계:**
1. **이전 결과물 문맥 파악**: previous_outputs_summary를 분석하여 이전에 무엇을 했는지, 어떤 목적과 요구사항이 있었는지 정확히 이해
2. **피드백 우선 반영**: feedback_summary를 최우선으로 분석하여 사용자가 원하는 개선사항과 요구사항을 파악하고 이를 폼 값 생성에 적극 반영
3. **연계성 확보**: 이전 작업의 흐름과 피드백 요구사항을 모두 고려하여 완전히 새로운 값이 아닌 개선된 폼 값 생성
4. **목적 정렬**: 최종 목표와 사용자 의도에 부합하는 실용적 값 생성

**핵심 규칙**:
1. **폼 타입 + HTML 기반 생성**: form_type 배열의 각 폼에 대해 key, type, text(폼 이름)을 분석하고, HTML 템플릿 내 해당 필드의 위젯 정의(예: radio의 items 등)를 함께 참고하여 값 생성
2. **타입별 적합성**: type과 text(폼 이름), HTML 위젯 속성을 모두 고려하여 적절한 형식의 값 생성
3. **평면 JSON 구조**: 중첩 객체나 추가 필드 절대 금지
4. **전문적 품질**: 구체적이고 상세한 값 생성 (플레이스홀더 금지)
5. **리포트 내용 활용**: report_content는 리포트 내용 또는 이전 결과물 중 하나가 전달됨
6. **피드백 반영**: 피드백이 제공되면 해당 피드백을 적극 반영하여 개선된 폼 값 생성
7. **분리된 처리**: 리포트 내용과 피드백은 별도로 분석하여 각각의 목적에 맞게 활용
8. **컨텍스트 활용**: 전달된 내용을 바탕으로 일관성 있는 값 생성

**타입별 값 생성 가이드**:
- **text 타입**: 
  * 이름이 "수량", "개수", "건수" 등 → 숫자 (예: "15", "2024")
  * 이름이 "날짜", "기한", "시간" 등 → 날짜/시간 형식 (예: "2024년 12월 25일")
  * 이름이 "이름", "제목", "분류" 등 → 간단한 텍스트
  * 이름이 "금액", "비용", "가격" 등 → 숫자와 단위 (예: "1,500,000원")
- **textarea 타입**: 상세한 설명이나 긴 텍스트 (여러 줄, 구체적 내용)
 - **radio 타입**: HTML 내 해당 필드(name 속성)의 items 속성(JSON 유사 문자열)에서 키(예: approve/reject) 목록을 파싱하고, 컨텍스트에 가장 적합한 키를 그대로 값으로 반환. 예: items="[{{'approve':'승인'}}, {{'reject':'반려'}}]" → "reject".

**담당자 관련 필드**: 전달된 담당자 정보를 기반으로, 이름, 부서, 직급, 이메일 등 관련 필드를 정확히 생성

**중요**: 폼 text를 면밀히 분석하여 의미에 맞는 실용적인 값을 생성하세요. 
예시: text가 "수량"이면 type이 text여도 숫자를 생성해야 합니다.

**출력 형식**:
form_type 배열의 각 폼 key를 JSON 키로 사용하는 평면 JSON 객체.

{{
  "form_key_1": "text와_type에_맞는_실용적_값",
  "form_key_2": "컨텍스트에_적합한_구체적_값"
}}

**필수 준수사항**:
- form_type에 있는 모든 key 포함
- form_type에 없는 키는 절대 추가 금지
- 중첩 구조나 그룹화 절대 금지
- 유효한 JSON 형식 출력
- 각 값은 구체적이고 전문적이며 현실적이어야 함
- 플레이스홀더나 예시 텍스트 사용 금지
 - radio의 경우 반드시 HTML items에서 정의된 키 중 하나를 선택하여 반환 (라벨이 아닌 키)

제공된 폼 타입 정보와 HTML 템플릿을 기반으로 고품질의 전문적인 값을 생성하여 완전한 JSON 객체로 출력하세요.
"""
    return prompt

def create_output_summary_prompt(outputs_str: str) -> str:
    """이전 결과물 요약 프롬프트 - 목차, 수치 관련 지시사항 보강"""
    return f"""다음 작업 결과를 체계적으로 정리해주세요:

{outputs_str}

**정리 원칙:**
- **구체적 정보 완전 보존**: 수치, 목차명, 섹션명, 인물명, 물건명, 날짜, 시간 등 객관적 정보는 반드시 원본 그대로 정확히 기록
- **정보 손실 방지**: 짧은 내용은 요약하지 말고 그대로 유지 (오히려 정보 손실 위험)
- **의미 보존**: 왜곡이나 의미 변경 절대 금지, 원본 의미 그대로 보존
- **효율적 정리**: 긴 내용만 적절히 요약하여 핵심 정보 전달
- **중복 제거**: 중복된 부분만 정리하고 핵심 내용은 모두 보존
- **통합성**: 하나의 통합된 문맥으로 작성하여 다음 작업자가 즉시 이해 가능

**특별 주의사항 - 목차 및 구조 정보:**
- **목차명**: 원본 목차 제목을 정확히 그대로 기록 (1자도 변경 금지)
- **섹션 구조**: 원본의 섹션 구조와 순서를 그대로 유지
- **번호 체계**: 목차 번호, 항목 번호 등을 원본과 정확히 일치시켜 기록
- **계층 구조**: 대분류, 소분류 등 계층 관계를 명확히 보존

**특별 주의사항 - 수치 및 데이터:**
- **모든 숫자**: 통계, 비율, 개수, 날짜, 시간 등 모든 수치를 정확히 기록
- **단위 포함**: 수치와 함께 단위(%, 개, 명, 원, 시간 등)도 함께 기록
- **범위/기간**: 날짜 범위, 시간대, 기간 등을 정확히 명시
- **비교 데이터**: 전년 대비, 이전 대비 등 비교 수치도 누락 없이 포함

**정리 방식:**
1. **목적과 배경**: 작업의 목적과 배경 정보를 명확히 기록
2. **핵심 결과물**: 완성된 내용의 구조와 세부사항을 체계적으로 정리
   - 목차가 있다면 원본 그대로 나열
   - 각 섹션별 핵심 내용 요약
3. **중요 데이터**: 수치, 통계, 목록 등 객관적 정보는 누락 없이 포함
4. **구조 유지**: 원본의 논리적 흐름과 구조를 최대한 보존

**출력 형식**: 통합된 하나의 완전한 문서로 작성 (불필요한 부연설명 제거, 객관적 사실만 포함)

**길이 제한**: 2000자 이내로 작성 (목차, 수치 등 핵심 정보는 유지하되 불필요한 부분만 압축)

⚠️ **절대 금지사항**: 목차명, 수치, 날짜, 인명 등의 변경이나 생략 절대 금지. 모든 구체적 정보는 원본과 100% 일치해야 함."""

def create_feedback_summary_prompt(feedbacks_str: str, contents_str: str = "") -> str:
    """피드백 정리 프롬프트 - 기존 프롬프트를 참고하여 보강"""
    
    # 피드백과 현재 결과물 모두 준비
    feedback_section = f"""=== 피드백 내용 ===
{feedbacks_str}""" if feedbacks_str and feedbacks_str.strip() else ""
    
    content_section = f"""=== 현재 결과물/작업 내용 ===
{contents_str}""" if contents_str and contents_str.strip() else ""
    
    return f"""다음은 사용자의 피드백과 결과물입니다. 이를 종합 분석하여 통합된 피드백을 작성해주세요:

{feedback_section}

{content_section}

**상황 분석 및 처리 방식:**
- **현재 결과물 품질 평가**: 어떤 점이 문제인지, 개선이 필요한지 구체적으로 판단
- **피드백 의도 파악**: 피드백의 진짜 의도와 숨은 요구사항을 정확히 파악
- **문제점 진단**: 결과물 자체, 작업 방식, 접근법 중 무엇이 문제인지 판단
- **개선 방향 제시**: 구체적이고 실행 가능한 개선 방안을 명확히 제시
- **현실적 분석**: 현재 결과물에 매몰되지 말고, 실제 어떤 부분이 문제인지 객관적 파악

**피드백 통합 및 분석 원칙:**
- **시간 흐름 이해**: 가장 최신 피드백을 최우선으로 하여 피드백들 간의 연결고리와 문맥을 파악
- **종합적 분석**: 결과물과 피드백을 함께 고려하여 핵심 문제점과 개선사항 도출
- **구체성 확보**: 추상적 지시가 아닌 구체적이고 실행 가능한 개선사항 제시
- **완전성 추구**: 자연스럽고 통합된 하나의 완전한 피드백으로 작성
- **명확성 확보**: 다음 작업자가 즉시 이해하고 실행할 수 있도록 명확하게 작성

**중요한 상황별 처리 방식:**
- **품질 문제**: 결과물 품질에 대한 불만 → 구체적인 품질 개선 방향 제시
- **방식 문제**: 작업 방식에 대한 불만 → 접근법 변경 및 새로운 방법론 제안
- **저장 문제**: 이전에 저장했는데 잘못 저장된 경우 → 정확한 수정 방법 제시
- **기능 추가**: 이전에 조회만 했는데 저장이 필요한 경우 → 필요한 저장 기능 명시
- **부분 수정**: 특정 부분만 수정이 필요한 경우 → 정확한 수정 범위와 방법 제시
- **전면 재작업**: 완전히 다시 시작해야 하는 경우 → 새로운 접근 방향 제시

**출력 형식**: 현재 상황을 종합적으로 분석한 완전한 피드백 문장 (최대 2500자까지 허용하여 상세히 작성)
**목표**: 다음 작업자가 이 피드백만 보고도 즉시 정확한 작업을 수행할 수 있도록 하는 것"""